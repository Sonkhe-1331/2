{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/sonkh/2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/sonkh/2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"C:/Users/sonkh/2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/sonkh/2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { A, Z, ZERO, NINE, SPACE, HOME, END, ENTER, ESCAPE, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';\nimport * as i0 from '@angular/core';\nimport { Directive, InjectionToken, EventEmitter, forwardRef, ElementRef, Component, ChangeDetectionStrategy, Inject, Optional, Input, Output, ViewChild, ContentChild, HostBinding, NgModule } from '@angular/core';\nimport * as i9 from '@angular/forms';\nimport { FormControl, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';\nimport * as i11 from '@angular/material/core';\nimport { _countGroupLabelsBeforeOption, MatOption } from '@angular/material/core';\nimport * as i12 from '@angular/material/form-field';\nimport { MatFormField } from '@angular/material/form-field';\nimport * as i10 from '@angular/material/select';\nimport { MatSelect } from '@angular/material/select';\nimport { BehaviorSubject, of, combineLatest, Subject } from 'rxjs';\nimport { switchMap, map, startWith, delay, takeUntil, take, filter, tap } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/scrolling';\nimport * as i2 from '@angular/cdk/a11y';\nimport * as i3 from '@angular/material/checkbox';\nimport { MatCheckboxModule } from '@angular/material/checkbox';\nimport * as i4 from '@angular/material/progress-spinner';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport * as i5 from '@angular/material/button';\nimport { MatButtonModule } from '@angular/material/button';\nimport * as i6 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i7 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i8 from '@angular/material/tooltip';\nimport { MatTooltipModule } from '@angular/material/tooltip';\n/**\n * Directive for providing a custom clear-icon.\n * e.g.\n * <ngx-mat-select-search [formControl]=\"bankFilterCtrl\">\n *   <mat-icon ngxMatSelectSearchClear>delete</mat-icon>\n * </ngx-mat-select-search>\n */\n\nvar _c0 = [\"searchSelectInput\"];\nvar _c1 = [\"innerSelectSearch\"];\n\nfunction MatSelectSearchComponent_mat_checkbox_3_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"mat-checkbox\", 9);\n    i0.ɵɵlistener(\"change\", function MatSelectSearchComponent_mat_checkbox_3_Template_mat_checkbox_change_0_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      var ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6._emitSelectAllBooleanToParent($event.checked);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"color\", ctx_r1.matFormField == null ? null : ctx_r1.matFormField.color)(\"checked\", ctx_r1.toggleAllCheckboxChecked)(\"indeterminate\", ctx_r1.toggleAllCheckboxIndeterminate)(\"matTooltip\", ctx_r1.toggleAllCheckboxTooltipMessage)(\"matTooltipPosition\", ctx_r1.toogleAllCheckboxTooltipPosition);\n  }\n}\n\nfunction MatSelectSearchComponent_mat_spinner_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"mat-spinner\", 10);\n  }\n}\n\nfunction MatSelectSearchComponent_button_7_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngIf\", \"clearIcon; else defaultIcon\"]);\n  }\n}\n\nfunction MatSelectSearchComponent_button_7_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\", 14);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r10.closeSvgIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", !ctx_r10.closeSvgIcon ? ctx_r10.closeIcon : null, \" \");\n  }\n}\n\nfunction MatSelectSearchComponent_button_7_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 11);\n    i0.ɵɵlistener(\"click\", function MatSelectSearchComponent_button_7_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r12);\n      var ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11._reset(true);\n    });\n    i0.ɵɵtemplate(1, MatSelectSearchComponent_button_7_ng_content_1_Template, 1, 0, \"ng-content\", 12);\n    i0.ɵɵtemplate(2, MatSelectSearchComponent_button_7_ng_template_2_Template, 2, 2, \"ng-template\", null, 13, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var _r9 = i0.ɵɵreference(3);\n\n    var ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.clearIcon)(\"ngIfElse\", _r9);\n  }\n}\n\nfunction MatSelectSearchComponent_div_9_ng_content_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"noEntriesFound; else defaultNoEntriesFound\"]);\n  }\n}\n\nfunction MatSelectSearchComponent_div_9_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    var ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵtextInterpolate(ctx_r15.noEntriesFoundLabel);\n  }\n}\n\nfunction MatSelectSearchComponent_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 15);\n    i0.ɵɵtemplate(1, MatSelectSearchComponent_div_9_ng_content_1_Template, 1, 0, \"ng-content\", 12);\n    i0.ɵɵtemplate(2, MatSelectSearchComponent_div_9_ng_template_2_Template, 1, 1, \"ng-template\", null, 16, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var _r14 = i0.ɵɵreference(3);\n\n    var ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.noEntriesFound)(\"ngIfElse\", _r14);\n  }\n}\n\nvar _c2 = [[[\"\", 8, \"mat-select-search-custom-header-content\"]], [[\"\", \"ngxMatSelectSearchClear\", \"\"]], [[\"\", \"ngxMatSelectNoEntriesFound\", \"\"]]];\n\nvar _c3 = function _c3(a0, a1) {\n  return {\n    \"mat-select-search-inner-multiple\": a0,\n    \"mat-select-search-inner-toggle-all\": a1\n  };\n};\n\nvar _c4 = [\".mat-select-search-custom-header-content\", \"[ngxMatSelectSearchClear]\", \"[ngxMatSelectNoEntriesFound]\"];\n\nvar MatSelectSearchClearDirective = /*#__PURE__*/_createClass(function MatSelectSearchClearDirective() {\n  _classCallCheck(this, MatSelectSearchClearDirective);\n});\n\nMatSelectSearchClearDirective.ɵfac = function MatSelectSearchClearDirective_Factory(t) {\n  return new (t || MatSelectSearchClearDirective)();\n};\n\nMatSelectSearchClearDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MatSelectSearchClearDirective,\n  selectors: [[\"\", \"ngxMatSelectSearchClear\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatSelectSearchClearDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxMatSelectSearchClear]'\n    }]\n  }], null, null);\n})();\n/** List of inputs of NgxMatSelectSearchComponent that can be configured with a global default. */\n\n\nvar configurableDefaultOptions = ['ariaLabel', 'clearSearchInput', 'closeIcon', 'closeSvgIcon', 'disableInitialFocus', 'disableScrollToActiveOnOptionsChanged', 'enableClearOnEscapePressed', 'hideClearSearchButton', 'indexAndLengthScreenReaderText', 'noEntriesFoundLabel', 'placeholderLabel', 'preventHomeEndKeyPropagation', 'searching'];\n/**\n * InjectionToken that can be used to specify global options. e.g.\n *\n * ```typescript\n * providers: [\n *   {\n *     provide: MAT_SELECTSEARCH_DEFAULT_OPTIONS,\n *     useValue: <MatSelectSearchOptions>{\n *       closeIcon: 'delete',\n *       noEntriesFoundLabel: 'No options found'\n *     }\n *   }\n * ]\n * ```\n *\n * See the corresponding inputs of `MatSelectSearchComponent` for documentation.\n */\n\nvar MAT_SELECTSEARCH_DEFAULT_OPTIONS = new InjectionToken('mat-selectsearch-default-options');\n/** @deprecated */\n\nvar configurableGlobalOptions = configurableDefaultOptions;\n/** @deprecated */\n\nvar MATSELECTSEARCH_GLOBAL_OPTIONS = MAT_SELECTSEARCH_DEFAULT_OPTIONS;\n/**\n * Directive for providing a custom no entries found element.\n * e.g.\n * <ngx-mat-select-search [formControl]=\"bankFilterCtrl\">\n *   <span ngxMatSelectNoEntriesFound>\n *     No entries found <button>Add</button>\n *   </span>\n * </ngx-mat-select-search>\n */\n\nvar MatSelectNoEntriesFoundDirective = /*#__PURE__*/_createClass(function MatSelectNoEntriesFoundDirective() {\n  _classCallCheck(this, MatSelectNoEntriesFoundDirective);\n});\n\nMatSelectNoEntriesFoundDirective.ɵfac = function MatSelectNoEntriesFoundDirective_Factory(t) {\n  return new (t || MatSelectNoEntriesFoundDirective)();\n};\n\nMatSelectNoEntriesFoundDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MatSelectNoEntriesFoundDirective,\n  selectors: [[\"\", \"ngxMatSelectNoEntriesFound\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatSelectNoEntriesFoundDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxMatSelectNoEntriesFound]'\n    }]\n  }], null, null);\n})();\n/** The max height of the select's overlay panel. */\n\n\nvar SELECT_PANEL_MAX_HEIGHT = 256;\n/* tslint:disable:member-ordering component-selector */\n\n/**\n * Component providing an input field for searching MatSelect options.\n *\n * Example usage:\n *\n * interface Bank {\n *  id: string;\n *  name: string;\n * }\n *\n * @Component({\n *   selector: 'my-app-data-selection',\n *   template: `\n *     <mat-form-field>\n *       <mat-select [formControl]=\"bankCtrl\" placeholder=\"Bank\">\n *         <mat-option>\n *           <ngx-mat-select-search [formControl]=\"bankFilterCtrl\"></ngx-mat-select-search>\n *         </mat-option>\n *         <mat-option *ngFor=\"let bank of filteredBanks | async\" [value]=\"bank.id\">\n *           {{bank.name}}\n *         </mat-option>\n *       </mat-select>\n *     </mat-form-field>\n *   `\n * })\n * export class DataSelectionComponent implements OnInit, OnDestroy {\n *\n *   // control for the selected bank\n *   public bankCtrl: FormControl = new FormControl();\n *   // control for the MatSelect filter keyword\n *   public bankFilterCtrl: FormControl = new FormControl();\n *\n *   // list of banks\n *   private banks: Bank[] = [{name: 'Bank A', id: 'A'}, {name: 'Bank B', id: 'B'}, {name: 'Bank C', id: 'C'}];\n *   // list of banks filtered by search keyword\n *   public filteredBanks: ReplaySubject<Bank[]> = new ReplaySubject<Bank[]>(1);\n *\n *   // Subject that emits when the component has been destroyed.\n *   private _onDestroy = new Subject<void>();\n *\n *\n *   ngOnInit() {\n *     // load the initial bank list\n *     this.filteredBanks.next(this.banks.slice());\n *     // listen for search field value changes\n *     this.bankFilterCtrl.valueChanges\n *       .pipe(takeUntil(this._onDestroy))\n *       .subscribe(() => {\n *         this.filterBanks();\n *       });\n *   }\n *\n *   ngOnDestroy() {\n *     this._onDestroy.next();\n *     this._onDestroy.complete();\n *   }\n *\n *   private filterBanks() {\n *     if (!this.banks) {\n *       return;\n *     }\n *\n *     // get the search keyword\n *     let search = this.bankFilterCtrl.value;\n *     if (!search) {\n *       this.filteredBanks.next(this.banks.slice());\n *       return;\n *     } else {\n *       search = search.toLowerCase();\n *     }\n *\n *     // filter the banks\n *     this.filteredBanks.next(\n *       this.banks.filter(bank => bank.name.toLowerCase().indexOf(search) > -1)\n *     );\n *   }\n * }\n */\n\nvar MatSelectSearchComponent = /*#__PURE__*/function () {\n  function MatSelectSearchComponent(matSelect, changeDetectorRef, _viewportRuler) {\n    var _this = this;\n\n    var matOption = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var liveAnnouncer = arguments.length > 4 ? arguments[4] : undefined;\n    var matFormField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var defaultOptions = arguments.length > 6 ? arguments[6] : undefined;\n\n    _classCallCheck(this, MatSelectSearchComponent);\n\n    this.matSelect = matSelect;\n    this.changeDetectorRef = changeDetectorRef;\n    this._viewportRuler = _viewportRuler;\n    this.matOption = matOption;\n    this.liveAnnouncer = liveAnnouncer;\n    this.matFormField = matFormField;\n    /** Label of the search placeholder */\n\n    this.placeholderLabel = 'Suche';\n    /** Type of the search input field */\n\n    this.type = 'text';\n    /** Font-based icon used for displaying Close-Icon */\n\n    this.closeIcon = 'close';\n    /** Label to be shown when no entries are found. Set to null if no message should be shown. */\n\n    this.noEntriesFoundLabel = 'Keine Optionen gefunden';\n    /**\n     *  Text that is appended to the currently active item label announced by screen readers,\n     *  informing the user of the current index, value and total options.\n     *  eg: Bank R (Germany) 1 of 6\n    */\n\n    this.indexAndLengthScreenReaderText = ' of ';\n    /**\n      * Whether or not the search field should be cleared after the dropdown menu is closed.\n      * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)\n      */\n\n    this.clearSearchInput = true;\n    /** Whether to show the search-in-progress indicator */\n\n    this.searching = false;\n    /** Disables initial focusing of the input field */\n\n    this.disableInitialFocus = false;\n    /** Enable clear input on escape pressed */\n\n    this.enableClearOnEscapePressed = false;\n    /**\n     * Prevents home / end key being propagated to mat-select,\n     * allowing to move the cursor within the search input instead of navigating the options\n     */\n\n    this.preventHomeEndKeyPropagation = false;\n    /** Disables scrolling to active options when option list changes. Useful for server-side search */\n\n    this.disableScrollToActiveOnOptionsChanged = false;\n    /** Adds 508 screen reader support for search box */\n\n    this.ariaLabel = 'dropdown search';\n    /** Whether to show Select All Checkbox (for mat-select[multi=true]) */\n\n    this.showToggleAllCheckbox = false;\n    /** select all checkbox checked state */\n\n    this.toggleAllCheckboxChecked = false;\n    /** select all checkbox indeterminate state */\n\n    this.toggleAllCheckboxIndeterminate = false;\n    /** Display a message in a tooltip on the toggle-all checkbox */\n\n    this.toggleAllCheckboxTooltipMessage = '';\n    /** Define the position of the tooltip on the toggle-all checkbox. */\n\n    this.toogleAllCheckboxTooltipPosition = 'below';\n    /** Show/Hide the search clear button of the search input */\n\n    this.hideClearSearchButton = false;\n    /**\n     * Always restore selected options on selectionChange for mode multi (e.g. for lazy loading/infinity scrolling).\n     * Defaults to false, so selected options are only restored while filtering is active.\n     */\n\n    this.alwaysRestoreSelectedOptionsMulti = false;\n    /** Output emitter to send to parent component with the toggle all boolean */\n\n    this.toggleAll = new EventEmitter();\n\n    this.onTouched = function (_) {};\n\n    this._options$ = new BehaviorSubject(null);\n    this.optionsList$ = this._options$.pipe(switchMap(function (_options) {\n      return _options ? _options.changes.pipe(map(function (options) {\n        return options.toArray();\n      }), startWith(_options.toArray())) : of(null);\n    }));\n    this.optionsLength$ = this.optionsList$.pipe(map(function (options) {\n      return options ? options.length : 0;\n    }));\n    this._formControl = new FormControl('');\n    /** whether to show the no entries found message */\n\n    this._showNoEntriesFound$ = combineLatest([this._formControl.valueChanges, this.optionsLength$]).pipe(map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          value = _ref2[0],\n          optionsLength = _ref2[1];\n\n      return _this.noEntriesFoundLabel && value && optionsLength === _this.getOptionsLengthOffset();\n    }));\n    /** Subject that emits when the component has been destroyed. */\n\n    this._onDestroy = new Subject();\n    this.applyDefaultOptions(defaultOptions);\n  }\n\n  _createClass(MatSelectSearchComponent, [{\n    key: \"isInsideMatOption\",\n    get: function get() {\n      return !!this.matOption;\n    }\n    /** Current search value */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._formControl.value;\n    }\n    /** Reference to the MatSelect options */\n\n  }, {\n    key: \"_options\",\n    get: function get() {\n      return this._options$.getValue();\n    },\n    set: function set(_options) {\n      this._options$.next(_options);\n    }\n  }, {\n    key: \"applyDefaultOptions\",\n    value: function applyDefaultOptions(defaultOptions) {\n      if (!defaultOptions) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper(configurableDefaultOptions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (defaultOptions.hasOwnProperty(key)) {\n            this[key] = defaultOptions[key];\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this2 = this;\n\n      // set custom panel class\n      var panelClass = 'mat-select-search-panel';\n\n      if (this.matSelect.panelClass) {\n        if (Array.isArray(this.matSelect.panelClass)) {\n          this.matSelect.panelClass.push(panelClass);\n        } else if (typeof this.matSelect.panelClass === 'string') {\n          this.matSelect.panelClass = [this.matSelect.panelClass, panelClass];\n        } else if (typeof this.matSelect.panelClass === 'object') {\n          this.matSelect.panelClass[panelClass] = true;\n        }\n      } else {\n        this.matSelect.panelClass = panelClass;\n      } // set custom mat-option class if the component was placed inside a mat-option\n\n\n      if (this.matOption) {\n        this.matOption.disabled = true;\n\n        this.matOption._getHostElement().classList.add('contains-mat-select-search');\n      } else {\n        console.error('<ngx-mat-select-search> must be placed inside a <mat-option> element');\n      } // when the select dropdown panel is opened or closed\n\n\n      this.matSelect.openedChange.pipe(delay(1), takeUntil(this._onDestroy)).subscribe(function (opened) {\n        if (opened) {\n          _this2.updateInputWidth(); // focus the search field when opening\n\n\n          if (!_this2.disableInitialFocus) {\n            _this2._focus();\n          }\n        } else {\n          // clear it when closing\n          if (_this2.clearSearchInput) {\n            _this2._reset();\n          }\n        }\n      }); // set the first item active after the options changed\n\n      this.matSelect.openedChange.pipe(take(1)).pipe(takeUntil(this._onDestroy)).subscribe(function () {\n        if (_this2.matSelect._keyManager) {\n          _this2.matSelect._keyManager.change.pipe(takeUntil(_this2._onDestroy)).subscribe(function () {\n            return _this2.adjustScrollTopToFitActiveOptionIntoView();\n          });\n        } else {\n          console.log('_keyManager was not initialized.');\n        }\n\n        _this2._options = _this2.matSelect.options; // Closure variable for tracking the most recent first option.\n        // In order to avoid avoid causing the list to\n        // scroll to the top when options are added to the bottom of\n        // the list (eg: infinite scroll), we compare only\n        // the changes to the first options to determine if we\n        // should set the first item as active.\n        // This prevents unnecessary scrolling to the top of the list\n        // when options are appended, but allows the first item\n        // in the list to be set as active by default when there\n        // is no active selection\n\n        var previousFirstOption = _this2._options.toArray()[_this2.getOptionsLengthOffset()];\n\n        _this2._options.changes.pipe(takeUntil(_this2._onDestroy)).subscribe(function () {\n          // avoid \"expression has been changed\" error\n          setTimeout(function () {\n            // Convert the QueryList to an array\n            var options = _this2._options.toArray(); // The true first item is offset by 1\n\n\n            var currentFirstOption = options[_this2.getOptionsLengthOffset()];\n\n            var keyManager = _this2.matSelect._keyManager;\n\n            if (keyManager && _this2.matSelect.panelOpen) {\n              // set first item active and input width\n              // Check to see if the first option in these changes is different from the previous.\n              var firstOptionIsChanged = !_this2.matSelect.compareWith(previousFirstOption, currentFirstOption); // CASE: The first option is different now.\n              // Indiciates we should set it as active and scroll to the top.\n\n              if (firstOptionIsChanged || !keyManager.activeItem || !options.find(function (option) {\n                return _this2.matSelect.compareWith(option, keyManager.activeItem);\n              })) {\n                keyManager.setFirstItemActive();\n              } // wait for panel width changes\n\n\n              setTimeout(function () {\n                _this2.updateInputWidth();\n              });\n\n              if (!_this2.disableScrollToActiveOnOptionsChanged) {\n                _this2.adjustScrollTopToFitActiveOptionIntoView();\n              }\n            } // Update our reference\n\n\n            previousFirstOption = currentFirstOption;\n          });\n        });\n      }); // add or remove css class depending on whether to show the no entries found message\n      // note: this is hacky\n\n      this._showNoEntriesFound$.pipe(takeUntil(this._onDestroy)).subscribe(function (showNoEntriesFound) {\n        // set no entries found class on mat option\n        if (_this2.matOption) {\n          if (showNoEntriesFound) {\n            _this2.matOption._getHostElement().classList.add('mat-select-search-no-entries-found');\n          } else {\n            _this2.matOption._getHostElement().classList.remove('mat-select-search-no-entries-found');\n          }\n        }\n      }); // resize the input width when the viewport is resized, i.e. the trigger width could potentially be resized\n\n\n      this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(function () {\n        if (_this2.matSelect.panelOpen) {\n          _this2.updateInputWidth();\n        }\n      });\n\n      this.initMultipleHandling();\n      this.optionsList$.pipe(takeUntil(this._onDestroy)).subscribe(function () {\n        // update view when available options change\n        _this2.changeDetectorRef.markForCheck();\n      });\n    }\n  }, {\n    key: \"_emitSelectAllBooleanToParent\",\n    value: function _emitSelectAllBooleanToParent(state) {\n      this.toggleAll.emit(state);\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._onDestroy.next();\n\n      this._onDestroy.complete();\n    }\n  }, {\n    key: \"_isToggleAllCheckboxVisible\",\n    value: function _isToggleAllCheckboxVisible() {\n      return this.matSelect.multiple && this.showToggleAllCheckbox;\n    }\n    /**\n     * Handles the key down event with MatSelect.\n     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.\n     * @param event\n     */\n\n  }, {\n    key: \"_handleKeydown\",\n    value: function _handleKeydown(event) {\n      var _this3 = this;\n\n      // Prevent propagation for all alphanumeric characters in order to avoid selection issues\n      if (event.key && event.key.length === 1 || event.keyCode >= A && event.keyCode <= Z || event.keyCode >= ZERO && event.keyCode <= NINE || event.keyCode === SPACE || this.preventHomeEndKeyPropagation && (event.keyCode === HOME || event.keyCode === END)) {\n        event.stopPropagation();\n      }\n\n      if (this.matSelect.multiple && event.key && event.keyCode === ENTER) {\n        // Regain focus after multiselect, so we can further type\n        setTimeout(function () {\n          return _this3._focus();\n        });\n      } // Special case if click Escape, if input is empty, close the dropdown, if not, empty out the search field\n\n\n      if (this.enableClearOnEscapePressed === true && event.keyCode === ESCAPE && this.value) {\n        this._reset(true);\n\n        event.stopPropagation();\n      }\n    }\n    /**\n     * Handles the key up event with MatSelect.\n     * Allows e.g. the announcing of the currently activeDescendant by screen readers.\n     */\n\n  }, {\n    key: \"_handleKeyup\",\n    value: function _handleKeyup(event) {\n      if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {\n        var ariaActiveDescendantId = this.matSelect._getAriaActiveDescendant();\n\n        var index = this._options.toArray().findIndex(function (item) {\n          return item.id === ariaActiveDescendantId;\n        });\n\n        if (index !== -1) {\n          var activeDescendant = this._options.toArray()[index];\n\n          this.liveAnnouncer.announce(activeDescendant.viewValue + ' ' + this.getAriaIndex(index) + this.indexAndLengthScreenReaderText + this.getAriaLength());\n        }\n      }\n    }\n    /**\n     * Calculate the index of the current option, taking the offset to length into account.\n     * examples:\n     *    Case 1 [Search, 1, 2, 3] will have offset of 1, due to search and will read index of total.\n     *    Case 2 [1, 2, 3] will have offset of 0 and will read index +1 of total.\n     */\n\n  }, {\n    key: \"getAriaIndex\",\n    value: function getAriaIndex(optionIndex) {\n      if (this.getOptionsLengthOffset() === 0) {\n        return optionIndex + 1;\n      }\n\n      return optionIndex;\n    }\n    /**\n     * Calculate the length of the options, taking the offset to length into account.\n     * examples:\n     *    Case 1 [Search, 1, 2, 3] will have length of options.length -1, due to search.\n     *    Case 2 [1, 2, 3] will have length of options.length.\n     */\n\n  }, {\n    key: \"getAriaLength\",\n    value: function getAriaLength() {\n      return this._options.toArray().length - this.getOptionsLengthOffset();\n    }\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      this._lastExternalInputValue = value;\n\n      this._formControl.setValue(value);\n\n      this.changeDetectorRef.markForCheck();\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      this.onTouched();\n    }\n  }, {\n    key: \"registerOnChange\",\n    value: function registerOnChange(fn) {\n      var _this4 = this;\n\n      this._formControl.valueChanges.pipe(filter(function (value) {\n        return value !== _this4._lastExternalInputValue;\n      }), tap(function () {\n        return _this4._lastExternalInputValue = undefined;\n      }), takeUntil(this._onDestroy)).subscribe(fn);\n    }\n  }, {\n    key: \"registerOnTouched\",\n    value: function registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Focuses the search input field\n     */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus() {\n      if (!this.searchSelectInput || !this.matSelect.panel) {\n        return;\n      } // save and restore scrollTop of panel, since it will be reset by focus()\n      // note: this is hacky\n\n\n      var panel = this.matSelect.panel.nativeElement;\n      var scrollTop = panel.scrollTop; // focus\n\n      this.searchSelectInput.nativeElement.focus();\n      panel.scrollTop = scrollTop;\n    }\n    /**\n     * Resets the current search value\n     * @param focus whether to focus after resetting\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset(focus) {\n      this._formControl.setValue('');\n\n      if (focus) {\n        this._focus();\n      }\n    }\n    /**\n     * Initializes handling <mat-select [multiple]=\"true\">\n     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.\n     */\n\n  }, {\n    key: \"initMultipleHandling\",\n    value: function initMultipleHandling() {\n      var _this5 = this;\n\n      if (!this.matSelect.ngControl) {\n        if (this.matSelect.multiple) {\n          // note: the access to matSelect.ngControl (instead of matSelect.value / matSelect.valueChanges)\n          // is necessary to properly work in multi-selection mode.\n          console.error('the mat-select containing ngx-mat-select-search must have a ngModel or formControl directive when multiple=true');\n        }\n\n        return;\n      } // if <mat-select [multiple]=\"true\">\n      // store previously selected values and restore them when they are deselected\n      // because the option is not available while we are currently filtering\n\n\n      this.previousSelectedValues = this.matSelect.ngControl.value;\n      this.matSelect.ngControl.valueChanges.pipe(takeUntil(this._onDestroy)).subscribe(function (values) {\n        var restoreSelectedValues = false;\n\n        if (_this5.matSelect.multiple) {\n          if ((_this5.alwaysRestoreSelectedOptionsMulti || _this5._formControl.value && _this5._formControl.value.length) && _this5.previousSelectedValues && Array.isArray(_this5.previousSelectedValues)) {\n            if (!values || !Array.isArray(values)) {\n              values = [];\n            }\n\n            var optionValues = _this5.matSelect.options.map(function (option) {\n              return option.value;\n            });\n\n            _this5.previousSelectedValues.forEach(function (previousValue) {\n              if (!values.some(function (v) {\n                return _this5.matSelect.compareWith(v, previousValue);\n              }) && !optionValues.some(function (v) {\n                return _this5.matSelect.compareWith(v, previousValue);\n              })) {\n                // if a value that was selected before is deselected and not found in the options, it was deselected\n                // due to the filtering, so we restore it.\n                values.push(previousValue);\n                restoreSelectedValues = true;\n              }\n            });\n          }\n        }\n\n        _this5.previousSelectedValues = values;\n\n        if (restoreSelectedValues) {\n          _this5.matSelect._onChange(values);\n        }\n      });\n    }\n    /**\n     * Scrolls the currently active option into the view if it is not yet visible.\n     */\n\n  }, {\n    key: \"adjustScrollTopToFitActiveOptionIntoView\",\n    value: function adjustScrollTopToFitActiveOptionIntoView() {\n      if (this.matSelect.panel && this.matSelect.options.length > 0) {\n        var matOptionHeight = this.getMatOptionHeight();\n        var activeOptionIndex = this.matSelect._keyManager.activeItemIndex || 0;\n\n        var labelCount = _countGroupLabelsBeforeOption(activeOptionIndex, this.matSelect.options, this.matSelect.optionGroups); // If the component is in a MatOption, the activeItemIndex will be offset by one.\n\n\n        var indexOfOptionToFitIntoView = (this.matOption ? -1 : 0) + labelCount + activeOptionIndex;\n        var currentScrollTop = this.matSelect.panel.nativeElement.scrollTop;\n        var searchInputHeight = this.innerSelectSearch.nativeElement.offsetHeight;\n        var amountOfVisibleOptions = Math.floor((SELECT_PANEL_MAX_HEIGHT - searchInputHeight) / matOptionHeight);\n        var indexOfFirstVisibleOption = Math.round((currentScrollTop + searchInputHeight) / matOptionHeight) - 1;\n\n        if (indexOfFirstVisibleOption >= indexOfOptionToFitIntoView) {\n          this.matSelect.panel.nativeElement.scrollTop = indexOfOptionToFitIntoView * matOptionHeight;\n        } else if (indexOfFirstVisibleOption + amountOfVisibleOptions <= indexOfOptionToFitIntoView) {\n          this.matSelect.panel.nativeElement.scrollTop = (indexOfOptionToFitIntoView + 1) * matOptionHeight - (SELECT_PANEL_MAX_HEIGHT - searchInputHeight);\n        }\n      }\n    }\n    /**\n     *  Set the width of the innerSelectSearch to fit even custom scrollbars\n     *  And support all Operation Systems\n     */\n\n  }, {\n    key: \"updateInputWidth\",\n    value: function updateInputWidth() {\n      if (!this.innerSelectSearch || !this.innerSelectSearch.nativeElement) {\n        return;\n      }\n\n      var element = this.innerSelectSearch.nativeElement;\n      var panelElement;\n\n      while (element = element.parentElement) {\n        if (element.classList.contains('mat-select-panel')) {\n          panelElement = element;\n          break;\n        }\n      }\n\n      if (panelElement) {\n        this.innerSelectSearch.nativeElement.style.width = panelElement.clientWidth + 'px';\n      }\n    }\n  }, {\n    key: \"getMatOptionHeight\",\n    value: function getMatOptionHeight() {\n      if (this.matSelect.options.length > 0) {\n        return this.matSelect.options.first._getHostElement().getBoundingClientRect().height;\n      }\n\n      return 0;\n    }\n    /**\n     * Determine the offset to length that can be caused by the optional matOption used as a search input.\n     */\n\n  }, {\n    key: \"getOptionsLengthOffset\",\n    value: function getOptionsLengthOffset() {\n      if (this.matOption) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }]);\n\n  return MatSelectSearchComponent;\n}();\n\nMatSelectSearchComponent.ɵfac = function MatSelectSearchComponent_Factory(t) {\n  return new (t || MatSelectSearchComponent)(i0.ɵɵdirectiveInject(MatSelect), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.ViewportRuler), i0.ɵɵdirectiveInject(MatOption, 8), i0.ɵɵdirectiveInject(i2.LiveAnnouncer), i0.ɵɵdirectiveInject(MatFormField, 8), i0.ɵɵdirectiveInject(MAT_SELECTSEARCH_DEFAULT_OPTIONS, 8));\n};\n\nMatSelectSearchComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: MatSelectSearchComponent,\n  selectors: [[\"ngx-mat-select-search\"]],\n  contentQueries: function MatSelectSearchComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, MatSelectSearchClearDirective, 5);\n      i0.ɵɵcontentQuery(dirIndex, MatSelectNoEntriesFoundDirective, 5);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clearIcon = _t.first);\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.noEntriesFound = _t.first);\n    }\n  },\n  viewQuery: function MatSelectSearchComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      i0.ɵɵviewQuery(_c1, 7, ElementRef);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.searchSelectInput = _t.first);\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.innerSelectSearch = _t.first);\n    }\n  },\n  hostVars: 2,\n  hostBindings: function MatSelectSearchComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"mat-select-search-inside-mat-option\", ctx.isInsideMatOption);\n    }\n  },\n  inputs: {\n    placeholderLabel: \"placeholderLabel\",\n    type: \"type\",\n    closeIcon: \"closeIcon\",\n    closeSvgIcon: \"closeSvgIcon\",\n    noEntriesFoundLabel: \"noEntriesFoundLabel\",\n    indexAndLengthScreenReaderText: \"indexAndLengthScreenReaderText\",\n    clearSearchInput: \"clearSearchInput\",\n    searching: \"searching\",\n    disableInitialFocus: \"disableInitialFocus\",\n    enableClearOnEscapePressed: \"enableClearOnEscapePressed\",\n    preventHomeEndKeyPropagation: \"preventHomeEndKeyPropagation\",\n    disableScrollToActiveOnOptionsChanged: \"disableScrollToActiveOnOptionsChanged\",\n    ariaLabel: \"ariaLabel\",\n    showToggleAllCheckbox: \"showToggleAllCheckbox\",\n    toggleAllCheckboxChecked: \"toggleAllCheckboxChecked\",\n    toggleAllCheckboxIndeterminate: \"toggleAllCheckboxIndeterminate\",\n    toggleAllCheckboxTooltipMessage: \"toggleAllCheckboxTooltipMessage\",\n    toogleAllCheckboxTooltipPosition: \"toogleAllCheckboxTooltipPosition\",\n    hideClearSearchButton: \"hideClearSearchButton\",\n    alwaysRestoreSelectedOptionsMulti: \"alwaysRestoreSelectedOptionsMulti\"\n  },\n  outputs: {\n    toggleAll: \"toggleAll\"\n  },\n  features: [i0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () {\n      return MatSelectSearchComponent;\n    }),\n    multi: true\n  }])],\n  ngContentSelectors: _c4,\n  decls: 11,\n  vars: 14,\n  consts: [[\"matInput\", \"\", 1, \"mat-select-search-input\", \"mat-select-search-hidden\"], [1, \"mat-select-search-inner\", \"mat-typography\", \"mat-datepicker-content\", \"mat-tab-header\", 3, \"ngClass\"], [\"innerSelectSearch\", \"\"], [\"class\", \"mat-select-search-toggle-all-checkbox\", \"matTooltipClass\", \"ngx-mat-select-search-toggle-all-tooltip\", 3, \"color\", \"checked\", \"indeterminate\", \"matTooltip\", \"matTooltipPosition\", \"change\", 4, \"ngIf\"], [\"autocomplete\", \"off\", 1, \"mat-select-search-input\", \"mat-input-element\", 3, \"type\", \"formControl\", \"placeholder\", \"keydown\", \"keyup\", \"blur\"], [\"searchSelectInput\", \"\"], [\"class\", \"mat-select-search-spinner\", \"diameter\", \"16\", 4, \"ngIf\"], [\"mat-button\", \"\", \"mat-icon-button\", \"\", \"aria-label\", \"Clear\", \"class\", \"mat-select-search-clear\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"mat-select-search-no-entries-found\", 4, \"ngIf\"], [\"matTooltipClass\", \"ngx-mat-select-search-toggle-all-tooltip\", 1, \"mat-select-search-toggle-all-checkbox\", 3, \"color\", \"checked\", \"indeterminate\", \"matTooltip\", \"matTooltipPosition\", \"change\"], [\"diameter\", \"16\", 1, \"mat-select-search-spinner\"], [\"mat-button\", \"\", \"mat-icon-button\", \"\", \"aria-label\", \"Clear\", 1, \"mat-select-search-clear\", 3, \"click\"], [4, \"ngIf\", \"ngIfElse\"], [\"defaultIcon\", \"\"], [3, \"svgIcon\"], [1, \"mat-select-search-no-entries-found\"], [\"defaultNoEntriesFound\", \"\"]],\n  template: function MatSelectSearchComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef(_c2);\n      i0.ɵɵelement(0, \"input\", 0);\n      i0.ɵɵelementStart(1, \"div\", 1, 2);\n      i0.ɵɵtemplate(3, MatSelectSearchComponent_mat_checkbox_3_Template, 1, 5, \"mat-checkbox\", 3);\n      i0.ɵɵelementStart(4, \"input\", 4, 5);\n      i0.ɵɵlistener(\"keydown\", function MatSelectSearchComponent_Template_input_keydown_4_listener($event) {\n        return ctx._handleKeydown($event);\n      })(\"keyup\", function MatSelectSearchComponent_Template_input_keyup_4_listener($event) {\n        return ctx._handleKeyup($event);\n      })(\"blur\", function MatSelectSearchComponent_Template_input_blur_4_listener() {\n        return ctx.onBlur();\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(6, MatSelectSearchComponent_mat_spinner_6_Template, 1, 0, \"mat-spinner\", 6);\n      i0.ɵɵtemplate(7, MatSelectSearchComponent_button_7_Template, 4, 2, \"button\", 7);\n      i0.ɵɵprojection(8);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(9, MatSelectSearchComponent_div_9_Template, 4, 2, \"div\", 8);\n      i0.ɵɵpipe(10, \"async\");\n    }\n\n    if (rf & 2) {\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(11, _c3, ctx.matSelect.multiple, ctx._isToggleAllCheckboxVisible()));\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx._isToggleAllCheckboxVisible());\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"type\", ctx.type)(\"formControl\", ctx._formControl)(\"placeholder\", ctx.placeholderLabel);\n      i0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.searching);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", !ctx.hideClearSearchButton && ctx.value && !ctx.searching);\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(10, 9, ctx._showNoEntriesFound$));\n    }\n  },\n  directives: [i3.MatCheckbox, i4.MatProgressSpinner, i5.MatButton, i6.MatIcon, i7.NgClass, i7.NgIf, i8.MatTooltip, i9.DefaultValueAccessor, i9.NgControlStatus, i9.FormControlDirective],\n  pipes: [i7.AsyncPipe],\n  styles: [\".mat-select-search-hidden[_ngcontent-%COMP%]{visibility:hidden}.mat-select-search-inner[_ngcontent-%COMP%]{position:absolute;top:0;width:100%;border-bottom-width:1px;border-bottom-style:solid;z-index:100;font-size:inherit;box-shadow:none;border-radius:4px 4px 0 0;-webkit-transform:translate3d(0,0,0)}.mat-select-search-inner.mat-select-search-inner-multiple[_ngcontent-%COMP%]{width:100%}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all[_ngcontent-%COMP%]{display:flex;align-items:center}.mat-select-search-inner[_ngcontent-%COMP%]   .mat-input-element[_ngcontent-%COMP%]{flex-basis:auto}.mat-select-search-inner[_ngcontent-%COMP%]   .mat-input-element[_ngcontent-%COMP%]:-ms-input-placeholder{-ms-user-select:text}  .mat-select-search-panel{transform:none!important;overflow-x:hidden}.mat-select-search-input[_ngcontent-%COMP%]{padding:16px 44px 16px 16px;box-sizing:border-box;width:100%}[dir=rtl][_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-right:16px;padding-left:44px}.mat-select-search-no-entries-found[_ngcontent-%COMP%]{padding:16px}.mat-select-search-clear[_ngcontent-%COMP%]{position:absolute;right:4px;top:5px}[dir=rtl][_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%]{right:auto;left:4px}.mat-select-search-spinner[_ngcontent-%COMP%]{position:absolute;right:16px;top:calc(50% - 8px)}[dir=rtl][_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-spinner[_ngcontent-%COMP%]{right:auto;left:16px}.mat-select-search-inside-mat-option[_nghost-%COMP%]   .mat-select-search-input[_ngcontent-%COMP%]{padding-top:0;padding-bottom:0;height:3em;line-height:3em}.mat-select-search-inside-mat-option[_nghost-%COMP%]   .mat-select-search-clear[_ngcontent-%COMP%]{top:3px}  .mat-option[aria-disabled=true].contains-mat-select-search{position:static;padding:0}  .mat-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}  .mat-option[aria-disabled=true].contains-mat-select-search .mat-option-pseudo-checkbox{display:none}  .mat-option[aria-disabled=true].contains-mat-select-search.mat-select-search-no-entries-found{height:6em}.mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:16px;padding-bottom:2px}[dir=rtl][_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .mat-select-search-toggle-all-checkbox[_ngcontent-%COMP%]{padding-left:0;padding-right:16px}\"],\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatSelectSearchComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-mat-select-search',\n      providers: [{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(function () {\n          return MatSelectSearchComponent;\n        }),\n        multi: true\n      }],\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: \"<!-- Placeholder to adjust vertical offset of the mat-option elements -->\\n<input matInput class=\\\"mat-select-search-input mat-select-search-hidden\\\"/>\\n\\n<!-- Note: the  mat-datepicker-content mat-tab-header are needed to inherit the material theme colors, see PR #22 -->\\n<div\\n      #innerSelectSearch\\n      class=\\\"mat-select-search-inner mat-typography mat-datepicker-content mat-tab-header\\\"\\n      [ngClass]=\\\"{'mat-select-search-inner-multiple': matSelect.multiple, 'mat-select-search-inner-toggle-all': _isToggleAllCheckboxVisible() }\\\">\\n\\n  <mat-checkbox *ngIf=\\\"_isToggleAllCheckboxVisible()\\\"\\n                [color]=\\\"matFormField?.color\\\"\\n                class=\\\"mat-select-search-toggle-all-checkbox\\\"\\n                [checked]=\\\"toggleAllCheckboxChecked\\\"\\n                [indeterminate]=\\\"toggleAllCheckboxIndeterminate\\\"\\n                [matTooltip]=\\\"toggleAllCheckboxTooltipMessage\\\"\\n                matTooltipClass=\\\"ngx-mat-select-search-toggle-all-tooltip\\\"\\n                [matTooltipPosition]=\\\"toogleAllCheckboxTooltipPosition\\\"\\n                (change)=\\\"_emitSelectAllBooleanToParent($event.checked)\\\"\\n  ></mat-checkbox>\\n\\n  <input class=\\\"mat-select-search-input mat-input-element\\\"\\n         autocomplete=\\\"off\\\"\\n         [type]=\\\"type\\\"\\n         [formControl]=\\\"_formControl\\\"\\n         #searchSelectInput\\n         (keydown)=\\\"_handleKeydown($event)\\\"\\n         (keyup)=\\\"_handleKeyup($event)\\\"\\n         (blur)=\\\"onBlur()\\\"\\n         [placeholder]=\\\"placeholderLabel\\\"\\n         [attr.aria-label]=\\\"ariaLabel\\\"\\n  />\\n  <mat-spinner *ngIf=\\\"searching\\\"\\n          class=\\\"mat-select-search-spinner\\\"\\n          diameter=\\\"16\\\"></mat-spinner>\\n\\n  <button mat-button\\n          *ngIf=\\\"!hideClearSearchButton && value && !searching\\\"\\n          mat-icon-button\\n          aria-label=\\\"Clear\\\"\\n          (click)=\\\"_reset(true)\\\"\\n          class=\\\"mat-select-search-clear\\\">\\n    <ng-content *ngIf=\\\"clearIcon; else defaultIcon\\\" select=\\\"[ngxMatSelectSearchClear]\\\"></ng-content>\\n    <ng-template #defaultIcon>\\n      <mat-icon [svgIcon]=\\\"closeSvgIcon\\\">\\n        {{!closeSvgIcon ? closeIcon : null}}\\n      </mat-icon>\\n    </ng-template>\\n  </button>\\n\\n  <ng-content select=\\\".mat-select-search-custom-header-content\\\"></ng-content>\\n\\n</div>\\n\\n<div *ngIf=\\\"_showNoEntriesFound$ | async\\\"\\n     class=\\\"mat-select-search-no-entries-found\\\">\\n  <ng-content *ngIf=\\\"noEntriesFound; else defaultNoEntriesFound\\\"\\n              select=\\\"[ngxMatSelectNoEntriesFound]\\\"></ng-content>\\n  <ng-template #defaultNoEntriesFound>{{noEntriesFoundLabel}}</ng-template>\\n</div>\\n<!--\\nCopyright (c) 2018 Bithost GmbH All Rights Reserved.\\n\\nUse of this source code is governed by an MIT-style license that can be\\nfound in the LICENSE file at https://angular.io/license\\n-->\\n\",\n      styles: [\".mat-select-search-hidden{visibility:hidden}.mat-select-search-inner{position:absolute;top:0;width:100%;border-bottom-width:1px;border-bottom-style:solid;z-index:100;font-size:inherit;box-shadow:none;border-radius:4px 4px 0 0;-webkit-transform:translate3d(0,0,0)}.mat-select-search-inner.mat-select-search-inner-multiple{width:100%}.mat-select-search-inner.mat-select-search-inner-multiple.mat-select-search-inner-toggle-all{display:flex;align-items:center}.mat-select-search-inner .mat-input-element{flex-basis:auto}.mat-select-search-inner .mat-input-element:-ms-input-placeholder{-ms-user-select:text}::ng-deep .mat-select-search-panel{transform:none!important;overflow-x:hidden}.mat-select-search-input{padding:16px 44px 16px 16px;box-sizing:border-box;width:100%}:host-context([dir=rtl]) .mat-select-search-input{padding-right:16px;padding-left:44px}.mat-select-search-no-entries-found{padding:16px}.mat-select-search-clear{position:absolute;right:4px;top:5px}:host-context([dir=rtl]) .mat-select-search-clear{right:auto;left:4px}.mat-select-search-spinner{position:absolute;right:16px;top:calc(50% - 8px)}:host-context([dir=rtl]) .mat-select-search-spinner{right:auto;left:16px}:host.mat-select-search-inside-mat-option .mat-select-search-input{padding-top:0;padding-bottom:0;height:3em;line-height:3em}:host.mat-select-search-inside-mat-option .mat-select-search-clear{top:3px}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search{position:static;padding:0}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search .mat-icon{margin-right:0;margin-left:0}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search .mat-option-pseudo-checkbox{display:none}::ng-deep .mat-option[aria-disabled=true].contains-mat-select-search.mat-select-search-no-entries-found{height:6em}.mat-select-search-toggle-all-checkbox{padding-left:16px;padding-bottom:2px}:host-context([dir=rtl]) .mat-select-search-toggle-all-checkbox{padding-left:0;padding-right:16px}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: i10.MatSelect,\n      decorators: [{\n        type: Inject,\n        args: [MatSelect]\n      }]\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: i1.ViewportRuler\n    }, {\n      type: i11.MatOption,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MatOption]\n      }]\n    }, {\n      type: i2.LiveAnnouncer\n    }, {\n      type: i12.MatFormField,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MatFormField]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAT_SELECTSEARCH_DEFAULT_OPTIONS]\n      }]\n    }];\n  }, {\n    placeholderLabel: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    closeIcon: [{\n      type: Input\n    }],\n    closeSvgIcon: [{\n      type: Input\n    }],\n    noEntriesFoundLabel: [{\n      type: Input\n    }],\n    indexAndLengthScreenReaderText: [{\n      type: Input\n    }],\n    clearSearchInput: [{\n      type: Input\n    }],\n    searching: [{\n      type: Input\n    }],\n    disableInitialFocus: [{\n      type: Input\n    }],\n    enableClearOnEscapePressed: [{\n      type: Input\n    }],\n    preventHomeEndKeyPropagation: [{\n      type: Input\n    }],\n    disableScrollToActiveOnOptionsChanged: [{\n      type: Input\n    }],\n    ariaLabel: [{\n      type: Input\n    }],\n    showToggleAllCheckbox: [{\n      type: Input\n    }],\n    toggleAllCheckboxChecked: [{\n      type: Input\n    }],\n    toggleAllCheckboxIndeterminate: [{\n      type: Input\n    }],\n    toggleAllCheckboxTooltipMessage: [{\n      type: Input\n    }],\n    toogleAllCheckboxTooltipPosition: [{\n      type: Input\n    }],\n    hideClearSearchButton: [{\n      type: Input\n    }],\n    alwaysRestoreSelectedOptionsMulti: [{\n      type: Input\n    }],\n    toggleAll: [{\n      type: Output\n    }],\n    searchSelectInput: [{\n      type: ViewChild,\n      args: ['searchSelectInput', {\n        read: ElementRef,\n        static: true\n      }]\n    }],\n    innerSelectSearch: [{\n      type: ViewChild,\n      args: ['innerSelectSearch', {\n        read: ElementRef,\n        static: true\n      }]\n    }],\n    clearIcon: [{\n      type: ContentChild,\n      args: [MatSelectSearchClearDirective]\n    }],\n    noEntriesFound: [{\n      type: ContentChild,\n      args: [MatSelectNoEntriesFoundDirective]\n    }],\n    isInsideMatOption: [{\n      type: HostBinding,\n      args: ['class.mat-select-search-inside-mat-option']\n    }]\n  });\n})();\n/**\n * Copyright (c) 2018 Bithost GmbH All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar MatSelectSearchVersion = '4.2.1';\n\nvar NgxMatSelectSearchModule = /*#__PURE__*/_createClass(function NgxMatSelectSearchModule() {\n  _classCallCheck(this, NgxMatSelectSearchModule);\n});\n\nNgxMatSelectSearchModule.ɵfac = function NgxMatSelectSearchModule_Factory(t) {\n  return new (t || NgxMatSelectSearchModule)();\n};\n\nNgxMatSelectSearchModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxMatSelectSearchModule\n});\nNgxMatSelectSearchModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule, ReactiveFormsModule, MatButtonModule, MatCheckboxModule, MatIconModule, MatProgressSpinnerModule, MatTooltipModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxMatSelectSearchModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, ReactiveFormsModule, MatButtonModule, MatCheckboxModule, MatIconModule, MatProgressSpinnerModule, MatTooltipModule],\n      declarations: [MatSelectSearchComponent, MatSelectSearchClearDirective, MatSelectNoEntriesFoundDirective],\n      exports: [MatSelectSearchComponent, MatSelectSearchClearDirective, MatSelectNoEntriesFoundDirective]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MATSELECTSEARCH_GLOBAL_OPTIONS, MAT_SELECTSEARCH_DEFAULT_OPTIONS, MatSelectNoEntriesFoundDirective, MatSelectSearchClearDirective, MatSelectSearchComponent, MatSelectSearchVersion, NgxMatSelectSearchModule, configurableDefaultOptions, configurableGlobalOptions }; //# sourceMappingURL=ngx-mat-select-search.mjs.map","map":null,"metadata":{},"sourceType":"module"}